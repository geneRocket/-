# 任务定义
分词，输入一个中文句子，输出一个一个词语序列。在给定训练数据，包括句子和对应的分词，学习一个映射函数，从句子到分词的映射。分词虽然是划分词语，但可以对每一个字来标注状态来划分词语，单个字的词是s，两个字的词是be，多个字的词是bii...ie,i的个数是词语长度减去2。这样将一个句子转换成长度相等的状态序列。例如“今天天气很好”，其状态序列是“bebess”。映射函数是学习一个句子到其状态的映射。


# 方法描述
读取1998年的人民日报语料
读取方法是读入每一行，使用空格划分，去掉第一个时间日期。有一是多个词语组成一个命名实体，在这里先忽略这个宏观的命名实体，去掉方括号和对应的词性。然后每一个部分是由词语和词性组成，中间由/来划分，由于任务是分词，用不到词性，这里取前面的词语。最后加到把句子加到列表当中。

# 建立状态序列
对于每一个句子，要分词，为了更好的匹配隐马尔科夫模型，隐马尔科夫考虑观察状态和其隐状态，这里构建分词的隐状态，单个字的词是s，两个字的词是be，多个字的词是bii...ie,i的个数是词语长度减去2。一个句子求出其与其长度相等的状态。把句子和状态序列组成一个元组加入到一个列表当中。供后续操作。

# 统计转移概率的分子和分母
转移概率是一个状态转换到下一个状态的概率，分母是一个原状态的个数，分子是由原状态到新状态的次数。同时还多了一个隐藏的开始状态和结尾状态，开始状态转移到第一个字的状态，最后一个字的状态转移到结尾状态。有5个分母，分别是b，i，e，s，和0，初始化值为0。分子的下标是一个元组，由两个状态组成，表示由第一个状态转移到第二个状态的次数。使用两重for循环遍历bie来初始化状态值为0.同时需要单独初始化开始的0状态到第一个字的状态，以及最后一个字的状态到f状态，其初始值也是0.
然后遍历读入预料时生成的句子和状态序列的列表。对于每一个句子和序列，从下标1开始，遍历整个句子，对应的分母和分子分别加1。同时注意到还有开始状态和结束状态，单独处理这两个特例，分别对0状态的分母、和0状态到第一个字的状态的分子加一，对最后一个字的状态的分母、最后一个字的状态转移到f状态的分子加1.

# 计算转移概率
遍历所有的分母，分子，计算对应的概率。两重for循环遍历所有状态序列，分母是一个for循环的值，分子是两个for循环的值组成的元组，用分子除以分母，就得到转移概率。

# 统计发射概率的分子和分母
每一个状态会暴露出一个观察现象，即是哪一个字。分母是状态的次数，分子是由这个状态发射出这个字的概率。遍历一遍文章，统计出对应的个数。遍历句子和状态元组成的列表，q是这个字的状态，o是这个字，把q作为分母的值加上1。把状态、字作为分子的下标，对应的值加上1.

# 计算发射概率
遍历每一个状态和字，计算观察概率，分子除以分母，保存概率。

# 分词
使用隐马尔可夫模型，每一个状态仅受上一个状态影响。同时每一个状态发射出一个字仅受这一个字的状态影响。所以一个句子的状态概率就是由对每一个字的转移状态和发射概率相乘。求出对应的状态序列，使这个概率最大。
使用动态规划来减少重复计算，不用遍历前面所有的字，仅需使用前一个字。定义一个动态规划状态，表示给定长度和状态，表示到这个长度以及状态的最大概率，所以求一个句子的复杂度是O（nm^2），n是句子长度，m是序列状态数量。需要保存一个动态规划每一步的是由哪一个状态转移过来的，这样才能在最后获取状态序列。
使用python字典用来存储动态规划的状态，这个状态是一个二维表，首先初始化 ，由0状态到第一个字的状态再乘以发射第一个字的概率。递推是使用上一个动态规划的状态乘以转移概率，乘以发射概率。终止最后一个字的状态乘以转移到f状态的概率。中间的地推过程使用三重for循环，第一重for遍历位置，第二重for遍历前一个位置的状态，第二个for遍历此位置的状态，每次选择记录的概率。
然后求动态规划的转移路径，之前在每一个状态中记录中了由哪一个状态转移而来，所以从最终的f状态，一步一步往回走，就能得到第一个字到最后一个字的状态。

# 改进优化

## 平滑概率
由于文本的稀疏性，在测试集上出现了训练集上没有的发射概率，这在训练集上从来没有发射过这一个字，所以统计频率为0，如果乘上只一个0，会使整个句子的概率值为0，使用一个平滑概率，值非常低，是1e-7，这样可以避免概率为0，同时取比较小可以避免影响到其他概率。同时测试了几个不同的值，看他们在测试集上的准确率，最终选择了准确率最高的1e-7。
## 对概率取log
当句子长度比较大的时候，通常长度为几百，概率值小于1，多个概率连乘会造成浮点数下溢，概率值变为0。这里对目标函数的连乘概率取log，变成log概率的和，这样就避免了溢出，同时因为log函数是单调递增函数，并不影响结果。动态规划状态不需要取log，因为是由多个概率的log值相加而来。
由于原来没有使用log的时候，不存在或者不合法的值用0替代即可，但是去log后，不能对0去log，换一种方法，使用python字典的key来判断是否存在值，若不存在，则跳过这个状态的处理。在for循环中加入对字典中是否包含这个key、以及这个key的值是否为0.
结果分析
# 训练集、测试集划分
训练集占80%，测试集占20%，遍历所有的句子的时候，对计数器取余10，若小于8则是训练集，若大于8则为测试集。这样可以随机的划分。
# 评估方法
评判方法使用了正确分词的比例。状态序列是由bies组成，同时遍历正确的状态序列和分词生成的状态序列，因为词语的结束只有b和s，把握住这两个就可以不漏掉词语。若同时遇到s，则分词正确。若遇到b，则记录开始位置。若同时遇到e，则判断他们的起始位置是否相同，若相同，则分词正确。最后在测试集上正确的分词的个数除以总的词语个数。
# 结果
结果能达到81.27662650384687%的精度。
# 源码运行环境
Python3
